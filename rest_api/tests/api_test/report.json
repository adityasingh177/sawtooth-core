{"environment": {"Plugins": {"tap": "2.2", "json-report": "0.7.0", "asyncio": "0.8.0", "cov": "2.5.1", "html": "1.17.0", "base-url": "1.4.1", "metadata": "1.7.0", "logger": "0.3.0"}, "Platform": "Linux-4.4.0-116-generic-x86_64-with-Ubuntu-16.04-xenial", "Python": "3.5.2", "Packages": {"pluggy": "0.7.1", "pytest": "3.7.1", "py": "1.5.4"}, "Base URL": ""}, "summary": {"error": 105, "passed": 3, "failed": 4, "total": 112}, "exitcode": 1, "created": 1535494538.4067698, "duration": 18.71592116355896, "root": "/home/aditya/sawtooth-local/rest_api/tests/api_test", "tests": [{"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list", "lineno": 57, "teardown": {"duration": 0.0003495216369628906, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list", "setup": {"duration": 0.7094748020172119, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 1590.996265411377, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 164, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494520.6833649, "levelname": "INFO", "msg": "Creating intkey transactions with set operations", "args": null, "levelno": 20, "msecs": 683.3648681640625, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:20", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 1593.996524810791, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 180, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494520.6863651, "levelname": "INFO", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelno": 20, "msecs": 686.3651275634766, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:20", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 1594.8295593261719, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 205, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494520.6871982, "levelname": "INFO", "msg": "Submitting batches to the handlers", "args": null, "levelno": 20, "msecs": 687.1981620788574, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:20", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 1604.0871143341064, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 211, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494520.6964557, "levelname": "INFO", "msg": "Rest Api is not reachable", "args": null, "levelno": 20, "msecs": 696.455717086792, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:20", "thread": 140335417706240}], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_batch_list", "batch", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_head", "lineno": 92, "teardown": {"duration": 0.0001475811004638672, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_head", "setup": {"duration": 0.0006263256072998047, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_list_head", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_bad_head", "lineno": 124, "teardown": {"duration": 0.00014543533325195312, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_bad_head", "setup": {"duration": 0.0003840923309326172, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_list_bad_head", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_id", "lineno": 139, "teardown": {"duration": 0.00015115737915039062, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_id", "setup": {"duration": 0.0003845691680908203, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_list_id", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_bad_id", "lineno": 174, "teardown": {"duration": 0.00014400482177734375, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_bad_id", "setup": {"duration": 0.0006825923919677734, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_list_bad_id", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_head_and_id", "lineno": 188, "teardown": {"duration": 0.0001494884490966797, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_head_and_id", "setup": {"duration": 0.000362396240234375, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_list_head_and_id", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_paginated_batch_list", "lineno": 223, "teardown": {"duration": 0.00018310546875, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_paginated_batch_list", "setup": {"duration": 0.0003848075866699219, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_paginated_batch_list", "batch", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_limit", "lineno": 242, "teardown": {"duration": 0.00020623207092285156, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_limit", "setup": {"duration": 0.0003688335418701172, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_batch_list_limit", "get/test_rest_api_get_batch.py", "api_test", "batch", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_invalid_start", "lineno": 279, "teardown": {"duration": 0.0001819133758544922, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_invalid_start", "setup": {"duration": 0.0004112720489501953, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "get", "()", "test_api_get_batch_list_invalid_start", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_invalid_limit", "lineno": 298, "teardown": {"duration": 0.00015616416931152344, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_invalid_limit", "setup": {"duration": 0.00039076805114746094, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "TestBatchList", "batch", "get", "()", "test_api_get_batch_list_invalid_limit"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_reversed", "lineno": 316, "teardown": {"duration": 0.00015974044799804688, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_list_reversed", "setup": {"duration": 0.00037980079650878906, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "get", "()", "TestBatchList", "test_api_get_batch_list_reversed"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_key_params", "lineno": 352, "teardown": {"duration": 0.0001494884490966797, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_key_params", "setup": {"duration": 0.0003905296325683594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_batch_key_params", "batch", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_param_link_val", "lineno": 361, "teardown": {"duration": 0.00014829635620117188, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_api_get_batch_param_link_val", "setup": {"duration": 0.00037026405334472656, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_param_link_val", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_rest_api_check_batches_count", "lineno": 376, "teardown": {"duration": 0.0001595020294189453, "log": [], "outcome": "passed"}, "domain": "TestBatchList.test_rest_api_check_batches_count", "setup": {"duration": 0.0003750324249267578, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "test_rest_api_check_batches_count", "api_test", "batch", "get", "()", "TestBatchList"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::()::test_api_get_batch_id", "lineno": 388, "teardown": {"duration": 0.0001506805419921875, "log": [], "outcome": "passed"}, "domain": "TestBatchGet.test_api_get_batch_id", "setup": {"duration": 0.00037217140197753906, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "TestBatchGet", "test_api_get_batch_id", "batch", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::()::test_api_get_bad_batch_id", "lineno": 413, "teardown": {"duration": 0.00015783309936523438, "log": [], "outcome": "passed"}, "domain": "TestBatchGet.test_api_get_bad_batch_id", "setup": {"duration": 0.0003705024719238281, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "TestBatchGet", "batch", "get", "()", "test_api_get_bad_batch_id"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_post_batch_status_15ids", "lineno": 429, "teardown": {"duration": 0.00015282630920410156, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_post_batch_status_15ids", "setup": {"duration": 0.00041675567626953125, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "TestBatchStatusesList", "test_api_post_batch_status_15ids", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_post_batch_status_10ids", "lineno": 446, "teardown": {"duration": 0.0001678466796875, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_post_batch_status_10ids", "setup": {"duration": 0.00039124488830566406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_post_batch_status_10ids", "batch", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses", "lineno": 466, "teardown": {"duration": 0.00015878677368164062, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses", "setup": {"duration": 0.0003802776336669922, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_batch_statuses", "batch", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_many_ids", "lineno": 486, "teardown": {"duration": 0.00015425682067871094, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_many_ids", "setup": {"duration": 0.00038361549377441406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "TestBatchStatusesList", "get", "()", "test_api_get_batch_statuses_many_ids"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_bad_id", "lineno": 507, "teardown": {"duration": 0.0001468658447265625, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_bad_id", "setup": {"duration": 0.0003910064697265625, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_batch_statuses_bad_id", "batch", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_invalid_query", "lineno": 522, "teardown": {"duration": 0.00014734268188476562, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_invalid_query", "setup": {"duration": 0.00036787986755371094, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_batch_statuses_invalid_query", "batch", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_wait", "lineno": 537, "teardown": {"duration": 0.0001518726348876953, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_wait", "setup": {"duration": 0.0003859996795654297, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_batch_statuses_wait", "batch", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_invalid", "lineno": 557, "teardown": {"duration": 0.00033020973205566406, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_invalid", "setup": {"duration": 0.02042102813720703, "longrepr": "@pytest.fixture(scope=\"function\")\n    def invalid_batch():\n        \"\"\"Setup method for creating invalid batches\n        \"\"\"\n        signer = get_signer()\n        data = {}\n        expected_trxns  = {}\n        expected_batches = []\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_invalid_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n    \n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['address'] = address\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nfixtures.py:129: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 2295.1555252075195, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 90, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "invalid_batch", "stack_info": null, "created": 1535494521.3875241, "levelname": "INFO", "msg": "Creating intkey transactions with set operations", "args": null, "levelno": 20, "msecs": 387.5241279602051, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:21", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 2297.311782836914, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 105, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "invalid_batch", "stack_info": null, "created": 1535494521.3896804, "levelname": "INFO", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelno": 20, "msecs": 389.6803855895996, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:21", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 2308.823585510254, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 128, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "invalid_batch", "stack_info": null, "created": 1535494521.4011922, "levelname": "INFO", "msg": "Rest Api is not reachable", "args": null, "levelno": 20, "msecs": 401.19218826293945, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:21", "thread": 140335417706240}], "traceback": [{"path": "fixtures.py", "lineno": 129, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_statuses_invalid", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_unknown", "lineno": 575, "teardown": {"duration": 0.0002231597900390625, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_unknown", "setup": {"duration": 0.0005159378051757812, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "test_api_get_batch_statuses_unknown", "batch", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_batch.py", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_default_wait", "lineno": 593, "teardown": {"duration": 0.0001926422119140625, "log": [], "outcome": "passed"}, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_default_wait", "setup": {"duration": 0.0004801750183105469, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["get/test_rest_api_get_batch.py", "api_test", "batch", "test_api_get_batch_statuses_default_wait", "TestBatchStatusesList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list", "lineno": 53, "teardown": {"duration": 0.00018095970153808594, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list", "setup": {"duration": 0.00044465065002441406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_api_get_block_list", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_head", "lineno": 68, "teardown": {"duration": 0.00016736984252929688, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_head", "setup": {"duration": 0.000392913818359375, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_block_list_head", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_bad_head", "lineno": 84, "teardown": {"duration": 0.00017499923706054688, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_bad_head", "setup": {"duration": 0.00039315223693847656, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_block_list_bad_head", "api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_id", "lineno": 97, "teardown": {"duration": 0.0001506805419921875, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_id", "setup": {"duration": 0.00038933753967285156, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_api_get_block_list_id", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_bad_id", "lineno": 116, "teardown": {"duration": 0.00014734268188476562, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_bad_id", "setup": {"duration": 0.00038361549377441406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_block_list_bad_id", "api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_head_and_id", "lineno": 130, "teardown": {"duration": 0.00014853477478027344, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_head_and_id", "setup": {"duration": 0.00036644935607910156, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_api_get_block_list_head_and_id", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_paginated_block_list", "lineno": 147, "teardown": {"duration": 0.00016760826110839844, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_paginated_block_list", "setup": {"duration": 0.00039267539978027344, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()", "test_api_get_paginated_block_list"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_start_id", "lineno": 166, "teardown": {"duration": 0.00016927719116210938, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_start_id", "setup": {"duration": 0.0003800392150878906, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "test_api_get_block_list_start_id", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_invalid_start", "lineno": 185, "teardown": {"duration": 0.0001480579376220703, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_invalid_start", "setup": {"duration": 0.00037360191345214844, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_api_get_block_list_invalid_start", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_limit", "lineno": 203, "teardown": {"duration": 0.00014543533325195312, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_limit", "setup": {"duration": 0.00038123130798339844, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "test_api_get_block_list_limit", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_invalid_limit", "lineno": 221, "teardown": {"duration": 0.0001590251922607422, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_invalid_limit", "setup": {"duration": 0.0003840923309326172, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "test_api_get_block_list_invalid_limit", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_reversed", "lineno": 240, "teardown": {"duration": 0.0001499652862548828, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_list_reversed", "setup": {"duration": 0.0003752708435058594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_block_list_reversed", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_link_val", "lineno": 259, "teardown": {"duration": 0.00018930435180664062, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_link_val", "setup": {"duration": 0.0003719329833984375, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_api_get_block_link_val", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_key_params", "lineno": 274, "teardown": {"duration": 0.0001659393310546875, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_block_key_params", "setup": {"duration": 0.0004112720489501953, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_block_key_params", "api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_each_batch_id_length", "lineno": 283, "teardown": {"duration": 0.0001995563507080078, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_each_batch_id_length", "setup": {"duration": 0.0004038810729980469, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_api_get_each_batch_id_length", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_first_block_id_length", "lineno": 295, "teardown": {"duration": 0.00016117095947265625, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_api_get_first_block_id_length", "setup": {"duration": 0.0004017353057861328, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_api_get_first_block_id_length", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_post_max_batches", "lineno": 308, "teardown": {"duration": 0.00016498565673828125, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_rest_api_check_post_max_batches", "setup": {"duration": 0.000408172607421875, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "test_rest_api_check_post_max_batches", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_head_signature", "lineno": 317, "teardown": {"duration": 0.00017452239990234375, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_rest_api_check_head_signature", "setup": {"duration": 0.0003705024719238281, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_rest_api_check_head_signature", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_family_version", "lineno": 327, "teardown": {"duration": 0.0001857280731201172, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_rest_api_check_family_version", "setup": {"duration": 0.00037932395935058594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "test_rest_api_check_family_version", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_input_output_content", "lineno": 336, "teardown": {"duration": 0.0001785755157470703, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_rest_api_check_input_output_content", "setup": {"duration": 0.0003972053527832031, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()", "test_rest_api_check_input_output_content"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_signer_public_key", "lineno": 345, "teardown": {"duration": 0.00015687942504882812, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_rest_api_check_signer_public_key", "setup": {"duration": 0.00039005279541015625, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_rest_api_check_signer_public_key", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_blocks_count", "lineno": 353, "teardown": {"duration": 0.0002467632293701172, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_rest_api_check_blocks_count", "setup": {"duration": 0.00039577484130859375, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "test_rest_api_check_blocks_count", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_blk_content_head_signature", "lineno": 364, "teardown": {"duration": 0.0001785755157470703, "log": [], "outcome": "passed"}, "domain": "TestBlockList.test_rest_api_blk_content_head_signature", "setup": {"duration": 0.0004382133483886719, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_rest_api_blk_content_head_signature", "get/test_rest_api_get_block.py", "block", "TestBlockList", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockGet::()::test_api_get_block_id", "lineno": 381, "teardown": {"duration": 0.0001513957977294922, "log": [], "outcome": "passed"}, "domain": "TestBlockGet.test_api_get_block_id", "setup": {"duration": 0.00039887428283691406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_block.py", "block", "TestBlockGet", "test_api_get_block_id", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_block.py", "nodeid": "get/test_rest_api_get_block.py::TestBlockGet::()::test_api_get_bad_block_id", "lineno": 396, "teardown": {"duration": 0.00018525123596191406, "log": [], "outcome": "passed"}, "domain": "TestBlockGet.test_api_get_bad_block_id", "setup": {"duration": 0.00037407875061035156, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get", "get/test_rest_api_get_block.py", "block", "test_api_get_bad_block_id", "TestBlockGet", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_peers.py", "nodeid": "get/test_rest_api_get_peers.py::TestPeerList::()::test_api_get_peer_list", "lineno": 35, "teardown": {"duration": 0.00015997886657714844, "log": [], "outcome": "passed"}, "domain": "TestPeerList.test_api_get_peer_list", "setup": {"duration": 0.0003864765167236328, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "TestPeerList", "peers", "get", "()", "get/test_rest_api_get_peers.py", "test_api_get_peer_list"], "outcome": "error"}, {"path": "get/test_rest_api_get_receipts.py", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_get_reciept_invalid_id", "call": {"duration": 0.013138771057128906, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "relativeCreated": 3085.4921340942383, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 50, "module": "test_rest_api_get_receipts", "process": 15359, "name": "test_rest_api_get_receipts", "funcName": "test_api_get_reciept_invalid_id", "stack_info": null, "created": 1535494522.1778607, "levelname": "INFO", "msg": "Rest Api is Unreachable", "args": null, "levelno": 20, "msecs": 177.86073684692383, "exc_info": null, "filename": "test_rest_api_get_receipts.py", "asctime": "2018-08-28 15:15:22", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "relativeCreated": 3086.174964904785, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 52, "module": "test_rest_api_get_receipts", "process": 15359, "name": "test_rest_api_get_receipts", "funcName": "test_api_get_reciept_invalid_id", "stack_info": null, "created": 1535494522.1785436, "levelname": "INFO", "msg": "Invalid Resource Id", "args": null, "levelno": 20, "msecs": 178.5435676574707, "exc_info": null, "filename": "test_rest_api_get_receipts.py", "asctime": "2018-08-28 15:15:22", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "relativeCreated": 3086.381673812866, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 53, "module": "test_rest_api_get_receipts", "process": 15359, "name": "test_rest_api_get_receipts", "funcName": "test_api_get_reciept_invalid_id", "stack_info": null, "created": 1535494522.1787503, "levelname": "INFO", "msg": "Blockchain items are identified by 128 character hex-strings. A submitted block, batch, or transaction id was invalid: s", "args": null, "levelno": 20, "msecs": 178.75027656555176, "exc_info": null, "filename": "test_rest_api_get_receipts.py", "asctime": "2018-08-28 15:15:22", "thread": 140335417706240}], "outcome": "passed"}, "lineno": 42, "teardown": {"duration": 0.0003857612609863281, "log": [], "outcome": "passed"}, "domain": "TestReceiptsList.test_api_get_reciept_invalid_id", "setup": {"duration": 0.0003578662872314453, "log": [], "outcome": "passed"}, "keywords": ["api_test", "test_api_get_reciept_invalid_id", "TestReceiptsList", "receipts", "get/test_rest_api_get_receipts.py", "get", "()"], "outcome": "passed"}, {"path": "get/test_rest_api_get_receipts.py", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_get_reciepts_multiple_transactions", "lineno": 56, "teardown": {"duration": 0.00039505958557128906, "log": [], "outcome": "passed"}, "domain": "TestReceiptsList.test_api_get_reciepts_multiple_transactions", "setup": {"duration": 0.03684234619140625, "longrepr": "@pytest.fixture(scope=\"function\")\n    def setup_batch_multiple_transaction():\n        data = {}\n        signer = get_signer()\n        transactions= []\n        expected_trxns  = []\n        expected_batches = []\n        initial_state_length = len(get_state_list())\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n        for val in range(15):\n            txns = create_intkey_transaction(\"set\", [] , 50 , signer)\n            transactions.append(txns)\n    \n    \n        for txn in transactions:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxns.append(trxn_id)\n    \n    \n        batch_s= create_batch(transactions, signer)\n        post_batch_list = BatchList(batches=[batch_s]).SerializeToString()\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            response = post_batch(post_batch_list)\n        except urllib.error.HTTPError as error:\n            LOGGER.info(\"Rest Api is not reachable\")\n>           data = json.loads(error.fp.read().decode('utf-8'))\n\nfixtures.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 3098.4489917755127, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 145, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "setup_batch_multiple_transaction", "stack_info": null, "created": 1535494522.1908176, "levelname": "INFO", "msg": "Creating intkey transactions with set operations", "args": null, "levelno": 20, "msecs": 190.81759452819824, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:22", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 3111.9637489318848, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 164, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "setup_batch_multiple_transaction", "stack_info": null, "created": 1535494522.2043324, "levelname": "INFO", "msg": "Submitting batches to the handlers", "args": null, "levelno": 20, "msecs": 204.3323516845703, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:22", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 3124.682903289795, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 169, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "setup_batch_multiple_transaction", "stack_info": null, "created": 1535494522.2170515, "levelname": "INFO", "msg": "Rest Api is not reachable", "args": null, "levelno": 20, "msecs": 217.05150604248047, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:22", "thread": 140335417706240}], "traceback": [{"path": "fixtures.py", "lineno": 170, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "TestReceiptsList", "test_api_get_reciepts_multiple_transactions", "receipts", "get/test_rest_api_get_receipts.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_receipts.py", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_get_reciepts_single_transactions", "lineno": 74, "teardown": {"duration": 0.0003516674041748047, "log": [], "outcome": "passed"}, "domain": "TestReceiptsList.test_api_get_reciepts_single_transactions", "setup": {"duration": 0.8049347400665283, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_reciepts_single_transactions'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 3942.5289630889893, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 164, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494523.0348976, "levelname": "INFO", "msg": "Creating intkey transactions with set operations", "args": null, "levelno": 20, "msecs": 34.897565841674805, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 3945.2998638153076, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 180, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494523.0376685, "levelname": "INFO", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelno": 20, "msecs": 37.668466567993164, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 3946.2475776672363, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 205, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494523.0386162, "levelname": "INFO", "msg": "Submitting batches to the handlers", "args": null, "levelno": 20, "msecs": 38.616180419921875, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/conftest.py", "relativeCreated": 3957.7133655548096, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 211, "module": "conftest", "process": 15359, "name": "conftest", "funcName": "setup", "stack_info": null, "created": 1535494523.050082, "levelname": "INFO", "msg": "Rest Api is not reachable", "args": null, "levelno": 20, "msecs": 50.08196830749512, "exc_info": null, "filename": "conftest.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_reciepts_single_transactions", "TestReceiptsList", "receipts", "get/test_rest_api_get_receipts.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_receipts.py", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_post_reciepts_single_transactions", "lineno": 90, "teardown": {"duration": 0.00016188621520996094, "log": [], "outcome": "passed"}, "domain": "TestReceiptsList.test_api_post_reciepts_single_transactions", "setup": {"duration": 0.0007164478302001953, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_reciepts_single_transactions'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_post_reciepts_single_transactions", "api_test", "TestReceiptsList", "receipts", "get/test_rest_api_get_receipts.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_receipts.py", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_post_reciepts_invalid_transactions", "call": {"duration": 0.016957998275756836, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "relativeCreated": 4030.696392059326, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 115, "module": "test_rest_api_get_receipts", "process": 15359, "name": "test_rest_api_get_receipts", "funcName": "test_api_post_reciepts_invalid_transactions", "stack_info": null, "created": 1535494523.123065, "levelname": "INFO", "msg": "Rest Api is Unreachable", "args": null, "levelno": 20, "msecs": 123.06499481201172, "exc_info": null, "filename": "test_rest_api_get_receipts.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "relativeCreated": 4031.355619430542, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 117, "module": "test_rest_api_get_receipts", "process": 15359, "name": "test_rest_api_get_receipts", "funcName": "test_api_post_reciepts_invalid_transactions", "stack_info": null, "created": 1535494523.1237242, "levelname": "INFO", "msg": "Bad Receipts Request", "args": null, "levelno": 20, "msecs": 123.72422218322754, "exc_info": null, "filename": "test_rest_api_get_receipts.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "relativeCreated": 4031.552314758301, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 118, "module": "test_rest_api_get_receipts", "process": 15359, "name": "test_rest_api_get_receipts", "funcName": "test_api_post_reciepts_invalid_transactions", "stack_info": null, "created": 1535494523.123921, "levelname": "INFO", "msg": "Requests for transaction receipts sent as a POST must have a JSON formatted body with an array of at least one id string.", "args": null, "levelno": 20, "msecs": 123.92091751098633, "exc_info": null, "filename": "test_rest_api_get_receipts.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}], "outcome": "passed"}, "lineno": 106, "teardown": {"duration": 0.00041103363037109375, "log": [], "outcome": "passed"}, "domain": "TestReceiptsList.test_api_post_reciepts_invalid_transactions", "setup": {"duration": 0.0003631114959716797, "log": [], "outcome": "passed"}, "keywords": ["api_test", "TestReceiptsList", "receipts", "get/test_rest_api_get_receipts.py", "get", "()", "test_api_post_reciepts_invalid_transactions"], "outcome": "passed"}, {"path": "get/test_rest_api_get_receipts.py", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_post_reciepts_multiple_transactions", "lineno": 121, "teardown": {"duration": 0.00045371055603027344, "log": [], "outcome": "passed"}, "domain": "TestReceiptsList.test_api_post_reciepts_multiple_transactions", "setup": {"duration": 0.03257942199707031, "longrepr": "@pytest.fixture(scope=\"function\")\n    def setup_batch_multiple_transaction():\n        data = {}\n        signer = get_signer()\n        transactions= []\n        expected_trxns  = []\n        expected_batches = []\n        initial_state_length = len(get_state_list())\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n        for val in range(15):\n            txns = create_intkey_transaction(\"set\", [] , 50 , signer)\n            transactions.append(txns)\n    \n    \n        for txn in transactions:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxns.append(trxn_id)\n    \n    \n        batch_s= create_batch(transactions, signer)\n        post_batch_list = BatchList(batches=[batch_s]).SerializeToString()\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            response = post_batch(post_batch_list)\n        except urllib.error.HTTPError as error:\n            LOGGER.info(\"Rest Api is not reachable\")\n>           data = json.loads(error.fp.read().decode('utf-8'))\n\nfixtures.py:170: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 4043.6127185821533, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 145, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "setup_batch_multiple_transaction", "stack_info": null, "created": 1535494523.1359813, "levelname": "INFO", "msg": "Creating intkey transactions with set operations", "args": null, "levelno": 20, "msecs": 135.98132133483887, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 4054.6600818634033, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 164, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "setup_batch_multiple_transaction", "stack_info": null, "created": 1535494523.1470287, "levelname": "INFO", "msg": "Submitting batches to the handlers", "args": null, "levelno": 20, "msecs": 147.02868461608887, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 4065.55438041687, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 169, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "setup_batch_multiple_transaction", "stack_info": null, "created": 1535494523.157923, "levelname": "INFO", "msg": "Rest Api is not reachable", "args": null, "levelno": 20, "msecs": 157.92298316955566, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}], "traceback": [{"path": "fixtures.py", "lineno": 170, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "TestReceiptsList", "receipts", "get/test_rest_api_get_receipts.py", "get", "()", "test_api_post_reciepts_multiple_transactions"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list", "lineno": 54, "teardown": {"duration": 0.00020933151245117188, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list", "setup": {"duration": 0.0007159709930419922, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_state_list", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_invalid_batch", "lineno": 71, "teardown": {"duration": 0.00042724609375, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_invalid_batch", "setup": {"duration": 0.020125627517700195, "longrepr": "@pytest.fixture(scope=\"function\")\n    def invalid_batch():\n        \"\"\"Setup method for creating invalid batches\n        \"\"\"\n        signer = get_signer()\n        data = {}\n        expected_trxns  = {}\n        expected_batches = []\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_invalid_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n    \n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['address'] = address\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nfixtures.py:129: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 4152.187347412109, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 90, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "invalid_batch", "stack_info": null, "created": 1535494523.244556, "levelname": "INFO", "msg": "Creating intkey transactions with set operations", "args": null, "levelno": 20, "msecs": 244.55595016479492, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 4154.111385345459, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 105, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "invalid_batch", "stack_info": null, "created": 1535494523.24648, "levelname": "INFO", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelno": 20, "msecs": 246.47998809814453, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/fixtures.py", "relativeCreated": 4165.291547775269, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 128, "module": "fixtures", "process": 15359, "name": "fixtures", "funcName": "invalid_batch", "stack_info": null, "created": 1535494523.2576602, "levelname": "INFO", "msg": "Rest Api is not reachable", "args": null, "levelno": 20, "msecs": 257.6601505279541, "exc_info": null, "filename": "fixtures.py", "asctime": "2018-08-28 15:15:23", "thread": 140335417706240}], "traceback": [{"path": "fixtures.py", "lineno": 129, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_state_list_invalid_batch", "api_test", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_head", "lineno": 83, "teardown": {"duration": 0.00016236305236816406, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_head", "setup": {"duration": 0.0007047653198242188, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_state_list_head", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_bad_head", "lineno": 99, "teardown": {"duration": 0.00015687942504882812, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_bad_head", "setup": {"duration": 0.0003857612609863281, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_state_list_bad_head", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_address", "lineno": 116, "teardown": {"duration": 0.00016307830810546875, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_address", "setup": {"duration": 0.00037169456481933594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_state_list_address", "api_test", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_bad_address", "lineno": 133, "teardown": {"duration": 0.0001595020294189453, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_bad_address", "setup": {"duration": 0.0003960132598876953, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py", "test_api_get_state_list_bad_address"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_paginated_state_list", "lineno": 149, "teardown": {"duration": 0.00014901161193847656, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_paginated_state_list", "setup": {"duration": 0.0003910064697265625, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_paginated_state_list", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_paginated_state_list_limit", "lineno": 168, "teardown": {"duration": 0.00016379356384277344, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_paginated_state_list_limit", "setup": {"duration": 0.0003752708435058594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_paginated_state_list_limit", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_paginated_state_list_start", "lineno": 185, "teardown": {"duration": 0.00015282630920410156, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_paginated_state_list_start", "setup": {"duration": 0.0003898143768310547, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_paginated_state_list_start", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_bad_paging", "lineno": 202, "teardown": {"duration": 0.0001780986785888672, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_bad_paging", "setup": {"duration": 0.00040078163146972656, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_state_list_bad_paging", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_invalid_start", "lineno": 222, "teardown": {"duration": 0.0001735687255859375, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_invalid_start", "setup": {"duration": 0.00038433074951171875, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_state_list_invalid_start", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_invalid_limit", "lineno": 241, "teardown": {"duration": 0.00015354156494140625, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_invalid_limit", "setup": {"duration": 0.000385284423828125, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_state_list_invalid_limit", "api_test", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_reversed", "lineno": 259, "teardown": {"duration": 0.00015091896057128906, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_list_reversed", "setup": {"duration": 0.00040721893310546875, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_state_list_reversed", "api_test", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_prefix_namespace", "lineno": 277, "teardown": {"duration": 0.000156402587890625, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_address_prefix_namespace", "setup": {"duration": 0.00040221214294433594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_state_data_address_prefix_namespace", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_head_wildcard_character", "lineno": 289, "teardown": {"duration": 0.00014925003051757812, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_head_wildcard_character", "setup": {"duration": 0.0003910064697265625, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get", "state", "TestStateList", "test_api_get_state_data_head_wildcard_character", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_head_partial_character", "lineno": 311, "teardown": {"duration": 0.00019168853759765625, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_head_partial_character", "setup": {"duration": 0.0003883838653564453, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_state_data_head_partial_character", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_partial_character", "lineno": 327, "teardown": {"duration": 0.00015735626220703125, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_address_partial_character", "setup": {"duration": 0.00040459632873535156, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_state.py", "state", "TestStateList", "get", "()", "test_api_get_state_data_address_partial_character"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_length", "lineno": 344, "teardown": {"duration": 0.0002028942108154297, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_address_length", "setup": {"duration": 0.00039124488830566406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "TestStateList", "test_api_get_state_data_address_length", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_with_odd_hex_value", "lineno": 358, "teardown": {"duration": 0.00018072128295898438, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_address_with_odd_hex_value", "setup": {"duration": 0.00040602684020996094, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_state_data_address_with_odd_hex_value", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_with_reduced_length", "lineno": 372, "teardown": {"duration": 0.00015282630920410156, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_address_with_reduced_length", "setup": {"duration": 0.0003876686096191406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_state_data_address_with_reduced_length", "api_test", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_64_Hex", "lineno": 386, "teardown": {"duration": 0.000156402587890625, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_address_64_Hex", "setup": {"duration": 0.0003724098205566406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "test_api_get_state_data_address_64_Hex", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_alter_bytes", "lineno": 401, "teardown": {"duration": 0.0001513957977294922, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_data_address_alter_bytes", "setup": {"duration": 0.0003783702850341797, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_state_data_address_alter_bytes", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_link_val", "lineno": 418, "teardown": {"duration": 0.0002346038818359375, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_link_val", "setup": {"duration": 0.00037169456481933594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_state_link_val", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_key_params", "lineno": 433, "teardown": {"duration": 0.00017309188842773438, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_state_key_params", "setup": {"duration": 0.00042057037353515625, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get/test_rest_api_get_state.py", "state", "TestStateList", "get", "()", "test_api_get_state_key_params"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_each_state_head_length", "lineno": 442, "teardown": {"duration": 0.00015282630920410156, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_api_get_each_state_head_length", "setup": {"duration": 0.00037026405334472656, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "test_api_get_each_state_head_length", "state", "TestStateList", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_rest_api_check_state_count", "lineno": 453, "teardown": {"duration": 0.0001685619354248047, "log": [], "outcome": "passed"}, "domain": "TestStateList.test_rest_api_check_state_count", "setup": {"duration": 0.0003695487976074219, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "get", "state", "TestStateList", "test_rest_api_check_state_count", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateGet::()::test_api_get_state_address", "lineno": 466, "teardown": {"duration": 0.00014853477478027344, "log": [], "outcome": "passed"}, "domain": "TestStateGet.test_api_get_state_address", "setup": {"duration": 0.000385284423828125, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_state_address", "api_test", "state", "TestStateGet", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_state.py", "nodeid": "get/test_rest_api_get_state.py::TestStateGet::()::test_api_get_bad_address", "lineno": 477, "teardown": {"duration": 0.00017213821411132812, "log": [], "outcome": "passed"}, "domain": "TestStateGet.test_api_get_bad_address", "setup": {"duration": 0.00036787986755371094, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "state", "TestStateGet", "test_api_get_bad_address", "get", "()", "get/test_rest_api_get_state.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list", "lineno": 49, "teardown": {"duration": 0.0001590251922607422, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list", "setup": {"duration": 0.00040912628173828125, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "TestTransactionList", "test_api_get_transaction_list", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_head", "lineno": 79, "teardown": {"duration": 0.0001709461212158203, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_head", "setup": {"duration": 0.0003795623779296875, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "TestTransactionList", "test_api_get_transaction_list_head", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_bad_head", "lineno": 108, "teardown": {"duration": 0.00021266937255859375, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_bad_head", "setup": {"duration": 0.00039696693420410156, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "test_api_get_transaction_list_bad_head", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_id", "lineno": 123, "teardown": {"duration": 0.00019502639770507812, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_id", "setup": {"duration": 0.00041365623474121094, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "test_api_get_transaction_list_id", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_bad_id", "lineno": 153, "teardown": {"duration": 0.00018978118896484375, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_bad_id", "setup": {"duration": 0.0004229545593261719, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "test_api_get_transaction_list_bad_id", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_head_and_id", "lineno": 167, "teardown": {"duration": 0.00015974044799804688, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_head_and_id", "setup": {"duration": 0.0003991127014160156, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "test_api_get_transaction_list_head_and_id", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_paginated_transaction_list", "lineno": 198, "teardown": {"duration": 0.00021338462829589844, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_paginated_transaction_list", "setup": {"duration": 0.00037932395935058594, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_paginated_transaction_list", "transactions", "api_test", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_bad_paging", "lineno": 217, "teardown": {"duration": 0.00016164779663085938, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_bad_paging", "setup": {"duration": 0.0004088878631591797, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_transaction_bad_paging", "api_test", "transactions", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_invalid_start", "lineno": 236, "teardown": {"duration": 0.00017881393432617188, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_invalid_start", "setup": {"duration": 0.0003876686096191406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "TestTransactionList", "test_api_get_transaction_list_invalid_start", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_invalid_limit", "lineno": 254, "teardown": {"duration": 0.00016498565673828125, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_invalid_limit", "setup": {"duration": 0.00038933753967285156, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "TestTransactionList", "test_api_get_transaction_list_invalid_limit", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_reversed", "lineno": 273, "teardown": {"duration": 0.00018215179443359375, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_list_reversed", "setup": {"duration": 0.00036907196044921875, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "test_api_get_transaction_list_reversed", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transactions_link_val", "lineno": 291, "teardown": {"duration": 0.0001552104949951172, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transactions_link_val", "setup": {"duration": 0.0003871917724609375, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "TestTransactionList", "test_api_get_transactions_link_val", "get", "()", "get/test_rest_api_get_transaction.py"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transactions_key_params", "lineno": 306, "teardown": {"duration": 0.00015306472778320312, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transactions_key_params", "setup": {"duration": 0.0003788471221923828, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "test_api_get_transactions_key_params", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_id_length", "lineno": 315, "teardown": {"duration": 0.0001506805419921875, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_api_get_transaction_id_length", "setup": {"duration": 0.00037670135498046875, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["test_api_get_transaction_id_length", "api_test", "transactions", "TestTransactionList", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_rest_api_check_transactions_count", "lineno": 327, "teardown": {"duration": 0.00017523765563964844, "log": [], "outcome": "passed"}, "domain": "TestTransactionList.test_rest_api_check_transactions_count", "setup": {"duration": 0.00036835670471191406, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "TestTransactionList", "test_rest_api_check_transactions_count", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet::()::test_api_get_transaction_id", "lineno": 339, "teardown": {"duration": 0.00014710426330566406, "log": [], "outcome": "passed"}, "domain": "TesttransactionGet.test_api_get_transaction_id", "setup": {"duration": 0.0003781318664550781, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "test_api_get_transaction_id", "TesttransactionGet", "get/test_rest_api_get_transaction.py", "get", "()"], "outcome": "error"}, {"path": "get/test_rest_api_get_transaction.py", "nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet::()::test_api_get_transaction_bad_id", "lineno": 361, "teardown": {"duration": 0.00016379356384277344, "log": [], "outcome": "passed"}, "domain": "TesttransactionGet.test_api_get_transaction_bad_id", "setup": {"duration": 0.0003669261932373047, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["api_test", "transactions", "TesttransactionGet", "get/test_rest_api_get_transaction.py", "test_api_get_transaction_bad_id", "get", "()"], "outcome": "error"}, {"path": "mul/test_rest_api_mul_validator.py", "nodeid": "mul/test_rest_api_mul_validator.py::TestMultiValidator::()::test_rest_api_mul_val_Node", "call": {"duration": 10.279750347137451, "log": [{"pathname": "/usr/local/lib/python3.5/dist-packages/paramiko/transport.py", "relativeCreated": 5346.7676639556885, "exc_text": null, "threadName": "Thread-1", "processName": "MainProcess", "lineno": 1687, "module": "transport", "process": 15359, "name": "paramiko.transport", "funcName": "_log", "stack_info": null, "_threadid": 1, "created": 1535494524.4391363, "levelname": "INFO", "msg": "Connected (version 2.0, client OpenSSH_7.2p2)", "args": null, "levelno": 20, "msecs": 439.136266708374, "exc_info": null, "filename": "transport.py", "asctime": "2018-08-28 15:15:24", "thread": 140335264392960}, {"pathname": "/usr/local/lib/python3.5/dist-packages/paramiko/transport.py", "relativeCreated": 5435.295104980469, "exc_text": null, "threadName": "Thread-1", "processName": "MainProcess", "lineno": 1687, "module": "transport", "process": 15359, "name": "paramiko.transport", "funcName": "_log", "stack_info": null, "_threadid": 1, "created": 1535494524.5276637, "levelname": "INFO", "msg": "Authentication (password) successful!", "args": null, "levelno": 20, "msecs": 527.6637077331543, "exc_info": null, "filename": "transport.py", "asctime": "2018-08-28 15:15:24", "thread": 140335264392960}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/workload.py", "relativeCreated": 5561.43045425415, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 24, "module": "workload", "process": 15359, "name": "workload", "funcName": "do_workload", "stack_info": null, "created": 1535494524.653799, "levelname": "INFO", "msg": "Starting Intkey Workload", "args": null, "levelno": 20, "msecs": 653.7990570068359, "exc_info": null, "filename": "workload.py", "asctime": "2018-08-28 15:15:24", "thread": 140335417706240}], "outcome": "passed"}, "lineno": 97, "teardown": {"duration": 0.0005924701690673828, "log": [], "outcome": "passed"}, "domain": "TestMultiValidator.test_rest_api_mul_val_Node", "setup": {"duration": 0.0003609657287597656, "log": [], "outcome": "passed"}, "keywords": ["api_test", "mul", "TestMultiValidator", "test_rest_api_mul_val_Node", "()", "mul/test_rest_api_mul_validator.py"], "outcome": "passed"}, {"path": "post/test_rest_api_post.py", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_post_batch", "call": {"duration": 2.131910800933838, "longrepr": "self = <test_rest_api_post.TestPost object at 0x7fa25a0779e8>\n\n    def test_rest_api_post_batch(self):\n        \"\"\"Tests that transactions are submitted and committed for\n            each block that are created by submitting intkey batches\n            with set operations\n            \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        initial_state_length = len(get_state_list()['data'])\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                data = error.fp.read().decode('utf-8')\n                LOGGER.info(data)\n    \n            block_batch_ids = [block['header']['batch_ids'][0] for block in get_blocks()['data']]\n            state_addresses = [state['address'] for state in get_state_list()['data']]\n            state_head_list = [get_state_address(address)['head'] for address in state_addresses]\n            committed_transaction_list = get_transactions()['data']\n    \n>           if response['data'][0]['status'] == 'COMMITTED':\nE           UnboundLocalError: local variable 'response' referenced before assignment\n\npost/test_rest_api_post.py:125: UnboundLocalError", "crash": {"path": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "lineno": 125, "message": "UnboundLocalError: local variable 'response' referenced before assignment"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "relativeCreated": 15593.21665763855, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 74, "module": "test_rest_api_post", "process": 15359, "name": "test_rest_api_post", "funcName": "test_rest_api_post_batch", "stack_info": null, "created": 1535494534.6855853, "levelname": "INFO", "msg": "Starting test for batch post", "args": null, "levelno": 20, "msecs": 685.5852603912354, "exc_info": null, "filename": "test_rest_api_post.py", "asctime": "2018-08-28 15:15:34", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "relativeCreated": 15820.361852645874, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 81, "module": "test_rest_api_post", "process": 15359, "name": "test_rest_api_post", "funcName": "test_rest_api_post_batch", "stack_info": null, "created": 1535494534.9127305, "levelname": "INFO", "msg": "Creating intkey transactions with set operations", "args": null, "levelno": 20, "msecs": 912.7304553985596, "exc_info": null, "filename": "test_rest_api_post.py", "asctime": "2018-08-28 15:15:34", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "relativeCreated": 15822.964668273926, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 96, "module": "test_rest_api_post", "process": 15359, "name": "test_rest_api_post", "funcName": "test_rest_api_post_batch", "stack_info": null, "created": 1535494534.9153333, "levelname": "INFO", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelno": 20, "msecs": 915.3332710266113, "exc_info": null, "filename": "test_rest_api_post.py", "asctime": "2018-08-28 15:15:34", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "relativeCreated": 15823.771476745605, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 111, "module": "test_rest_api_post", "process": 15359, "name": "test_rest_api_post", "funcName": "test_rest_api_post_batch", "stack_info": null, "created": 1535494534.91614, "levelname": "INFO", "msg": "Submitting batches to the handlers", "args": null, "levelno": 20, "msecs": 916.140079498291, "exc_info": null, "filename": "test_rest_api_post.py", "asctime": "2018-08-28 15:15:34", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "relativeCreated": 15835.410594940186, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 118, "module": "test_rest_api_post", "process": 15359, "name": "test_rest_api_post", "funcName": "test_rest_api_post_batch", "stack_info": null, "created": 1535494534.9277792, "levelname": "INFO", "msg": "<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>", "args": null, "levelno": 20, "msecs": 927.7791976928711, "exc_info": null, "filename": "test_rest_api_post.py", "asctime": "2018-08-28 15:15:34", "thread": 140335417706240}], "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 125, "message": "UnboundLocalError"}], "outcome": "failed"}, "lineno": 68, "teardown": {"duration": 0.0006928443908691406, "log": [], "outcome": "passed"}, "domain": "TestPost.test_rest_api_post_batch", "setup": {"duration": 0.0008955001831054688, "log": [], "outcome": "passed"}, "keywords": ["post", "api_test", "TestPost", "post/test_rest_api_post.py", "test_rest_api_post_batch", "()"], "outcome": "failed"}, {"path": "post/test_rest_api_post.py", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_no_batches", "call": {"duration": 0.011679649353027344, "longrepr": "self = <test_rest_api_post.TestPost object at 0x7fa25a138a90>\n\n    def test_rest_api_no_batches(self):\n        LOGGER.info(\"Starting test for batch with bad protobuf\")\n    \n        try:\n            response = post_batch(batch=EMPTY_BATCH)\n        except urllib.error.HTTPError as error:\n>           response = json.loads(error.fp.read().decode('utf-8'))\n\npost/test_rest_api_post.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "relativeCreated": 17745.764017105103, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 150, "module": "test_rest_api_post", "process": 15359, "name": "test_rest_api_post", "funcName": "test_rest_api_no_batches", "stack_info": null, "created": 1535494536.8381326, "levelname": "INFO", "msg": "Starting test for batch with bad protobuf", "args": null, "levelno": 20, "msecs": 838.1326198577881, "exc_info": null, "filename": "test_rest_api_post.py", "asctime": "2018-08-28 15:15:36", "thread": 140335417706240}], "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 155, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "lineno": 148, "teardown": {"duration": 0.00042247772216796875, "log": [], "outcome": "passed"}, "domain": "TestPost.test_rest_api_no_batches", "setup": {"duration": 0.0006954669952392578, "log": [], "outcome": "passed"}, "keywords": ["post", "api_test", "TestPost", "post/test_rest_api_post.py", "test_rest_api_no_batches", "()"], "outcome": "failed"}, {"path": "post/test_rest_api_post.py", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_bad_protobuf", "call": {"duration": 0.012860536575317383, "longrepr": "self = <test_rest_api_post.TestPost object at 0x7fa25a1db2e8>\n\n    def test_rest_api_bad_protobuf(self):\n        LOGGER.info(\"Starting test for batch with bad protobuf\")\n    \n        try:\n            response = post_batch(batch=BAD_PROTOBUF)\n        except urllib.error.HTTPError as error:\n>           response = json.loads(error.fp.read().decode('utf-8'))\n\npost/test_rest_api_post.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/post/test_rest_api_post.py", "relativeCreated": 17790.005683898926, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 162, "module": "test_rest_api_post", "process": 15359, "name": "test_rest_api_post", "funcName": "test_rest_api_bad_protobuf", "stack_info": null, "created": 1535494536.8823743, "levelname": "INFO", "msg": "Starting test for batch with bad protobuf", "args": null, "levelno": 20, "msecs": 882.3742866516113, "exc_info": null, "filename": "test_rest_api_post.py", "asctime": "2018-08-28 15:15:36", "thread": 140335417706240}], "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 167, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "lineno": 160, "teardown": {"duration": 0.0003960132598876953, "log": [], "outcome": "passed"}, "domain": "TestPost.test_rest_api_bad_protobuf", "setup": {"duration": 0.0007112026214599609, "log": [], "outcome": "passed"}, "keywords": ["test_rest_api_bad_protobuf", "post", "api_test", "TestPost", "post/test_rest_api_post.py", "()"], "outcome": "failed"}, {"path": "post/test_rest_api_post.py", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_post_wrong_header", "lineno": 172, "teardown": {"duration": 0.00021910667419433594, "log": [], "outcome": "passed"}, "domain": "TestPost.test_rest_api_post_wrong_header", "setup": {"duration": 0.0007345676422119141, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["post", "api_test", "TestPost", "post/test_rest_api_post.py", "test_rest_api_post_wrong_header", "()"], "outcome": "error"}, {"path": "post/test_rest_api_post.py", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_post_same_txns", "lineno": 225, "teardown": {"duration": 0.00020551681518554688, "log": [], "outcome": "passed"}, "domain": "TestPost.test_rest_api_post_same_txns", "setup": {"duration": 0.00041675567626953125, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["post", "api_test", "test_rest_api_post_same_txns", "TestPost", "post/test_rest_api_post.py", "()"], "outcome": "error"}, {"path": "post/test_rest_api_post.py", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_multiple_txns_batches", "lineno": 279, "teardown": {"duration": 0.0001990795135498047, "log": [], "outcome": "passed"}, "domain": "TestPost.test_rest_api_multiple_txns_batches", "setup": {"duration": 0.00043320655822753906, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["post", "api_test", "TestPost", "post/test_rest_api_post.py", "()", "test_rest_api_multiple_txns_batches"], "outcome": "error"}, {"path": "post/test_rest_api_post.py", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_api_post_batch_different_signer", "lineno": 355, "teardown": {"duration": 0.00017070770263671875, "log": [], "outcome": "passed"}, "domain": "TestPost.test_api_post_batch_different_signer", "setup": {"duration": 0.0004124641418457031, "longrepr": "request = <SubRequest 'setup' for <Function 'test_api_get_batch_list'>>\n\n    @pytest.fixture(scope=\"session\")\n    def setup(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        data = {}\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        transaction_list = []\n        initial_state_length = len(get_state_list())\n        initial_batch_length = batch_count()\n        initial_transaction_length = transaction_count()\n        address = _get_client_address()\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            dict = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = dict['header_signature']\n            expected_batches.append(batch_id)\n    \n        length_batches = len(expected_batches)\n        length_transactions = len(expected_trxns)\n    \n        data['expected_batch_length'] = initial_batch_length + length_batches\n        data['expected_trn_length'] = initial_transaction_length + length_transactions\n        data['expected_txns'] = expected_trxns['trxn_id'][::-1]\n        data['payload'] = expected_trxns['payload'][::-1]\n        data['expected_batches'] = expected_batches[::-1]\n        data['signer_key'] = signer.get_public_key().as_hex()\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        for batch in post_batch_list:\n            try:\n                response = post_batch(batch)\n            except urllib.error.HTTPError as error:\n                LOGGER.info(\"Rest Api is not reachable\")\n>               response = json.loads(error.fp.read().decode('utf-8'))\n\nconftest.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.5/json/__init__.py:319: in loads\n    return _default_decoder.decode(s)\n/usr/lib/python3.5/json/decoder.py:339: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7fa25f56d0f0>\ns = '<html><head><title>500 Internal Server Error</title></head><body><h1>500 Internal Server Error</h1>Server got itself in trouble</body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n            a JSON document) and return a 2-tuple of the Python\n            representation and the index in ``s`` where the document ended.\n    \n            This can be used to decode a JSON document from a string that may\n            have extraneous data at the end.\n    \n            \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n/usr/lib/python3.5/json/decoder.py:357: JSONDecodeError", "crash": {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"}, "log": [], "traceback": [{"path": "conftest.py", "lineno": 212, "message": ""}, {"path": "/usr/lib/python3.5/json/__init__.py", "lineno": 319, "message": "in loads"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 339, "message": "in decode"}, {"path": "/usr/lib/python3.5/json/decoder.py", "lineno": 357, "message": "JSONDecodeError"}], "outcome": "failed"}, "keywords": ["post", "api_test", "TestPost", "post/test_rest_api_post.py", "test_api_post_batch_different_signer", "()"], "outcome": "error"}, {"path": "scenario/test_rest_api_scenario.py", "nodeid": "scenario/test_rest_api_scenario.py::TestScenario::()::test_rest_api_mul_val_intk_xo", "call": {"duration": 1.2778630256652832, "longrepr": "self = <test_rest_api_scenario.TestScenario object at 0x7fa259986b70>\n\n    def test_rest_api_mul_val_intk_xo(self):\n        \"\"\"Tests that transactions are submitted and committed for\n            each block that are created by submitting intkey and XO batches\n            \"\"\"\n        signer = get_signer()\n        expected_trxns  = {}\n        expected_batches = []\n        node_list = [{_get_client_address()}]\n    \n        LOGGER.info('Starting Test for Intkey and Xo as payload')\n    \n        LOGGER.info(\"Creating intkey batches\")\n    \n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            dict = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            expected_trxns['trxn_id'] = [dict['header_signature']]\n            expected_trxns['payload'] = [dict['payload']]\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        LOGGER.info(\"Creating keys for xo users\")\n    \n        for username in ('aditya', 'singh'):\n            _send_cmd('sawtooth keygen {} --force'.format(username))\n    \n    \n        LOGGER.info(\"Submitting xo batches to the handlers\")\n    \n    \n        xo_cmds = (\n                'xo create game-1 --username aditya',\n                'xo take game-1 1 --username singh',\n                'xo take game-1 4 --username aditya',\n                'xo take game-1 2 --username singh',\n            )\n    \n        for cmd in xo_cmds:\n                _send_cmd(\n                    '{} --url {} --wait {}'.format(\n                        cmd,\n                        _get_client_address(),\n>                       WAIT))\n\nscenario/test_rest_api_scenario.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nutils.py:270: in _send_cmd\n    check=True)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ninput = None, timeout = None, check = True\npopenargs = (['xo', 'create', 'game-1', '--username', 'aditya', '--url', ...],)\nkwargs = {}, process = <subprocess.Popen object at 0x7fa2599866d8>\nstdout = None, stderr = None, retcode = 1\n\n    def run(*popenargs, input=None, timeout=None, check=False, **kwargs):\n        \"\"\"Run command with arguments and return a CompletedProcess instance.\n    \n        The returned instance will have attributes args, returncode, stdout and\n        stderr. By default, stdout and stderr are not captured, and those attributes\n        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n    \n        If check is True and the exit code was non-zero, it raises a\n        CalledProcessError. The CalledProcessError object will have the return code\n        in the returncode attribute, and output & stderr attributes if those streams\n        were captured.\n    \n        If timeout is given, and the process takes too long, a TimeoutExpired\n        exception will be raised.\n    \n        There is an optional argument \"input\", allowing you to\n        pass a string to the subprocess's stdin.  If you use this argument\n        you may not also use the Popen constructor's \"stdin\" argument, as\n        it will be used internally.\n    \n        The other arguments are the same as for the Popen constructor.\n    \n        If universal_newlines=True is passed, the \"input\" argument must be a\n        string and stdout/stderr in the returned object will be strings rather than\n        bytes.\n        \"\"\"\n        if input is not None:\n            if 'stdin' in kwargs:\n                raise ValueError('stdin and input arguments may not both be used.')\n            kwargs['stdin'] = PIPE\n    \n        with Popen(*popenargs, **kwargs) as process:\n            try:\n                stdout, stderr = process.communicate(input, timeout=timeout)\n            except TimeoutExpired:\n                process.kill()\n                stdout, stderr = process.communicate()\n                raise TimeoutExpired(process.args, timeout, output=stdout,\n                                     stderr=stderr)\n            except:\n                process.kill()\n                process.wait()\n                raise\n            retcode = process.poll()\n            if check and retcode:\n                raise CalledProcessError(retcode, process.args,\n>                                        output=stdout, stderr=stderr)\nE               subprocess.CalledProcessError: Command '['xo', 'create', 'game-1', '--username', 'aditya', '--url', 'http://10.223.155.43:8008', '--wait', '300']' returned non-zero exit status 1\n\n/usr/lib/python3.5/subprocess.py:708: CalledProcessError", "crash": {"path": "/usr/lib/python3.5/subprocess.py", "lineno": 708, "message": "subprocess.CalledProcessError: Command '['xo', 'create', 'game-1', '--username', 'aditya', '--url', 'http://10.223.155.43:8008', '--wait', '300']' returned non-zero exit status 1"}, "log": [{"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/scenario/test_rest_api_scenario.py", "relativeCreated": 17976.590633392334, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 61, "module": "test_rest_api_scenario", "process": 15359, "name": "test_rest_api_scenario", "funcName": "test_rest_api_mul_val_intk_xo", "stack_info": null, "created": 1535494537.0689592, "levelname": "INFO", "msg": "Starting Test for Intkey and Xo as payload", "args": null, "levelno": 20, "msecs": 68.95923614501953, "exc_info": null, "filename": "test_rest_api_scenario.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/scenario/test_rest_api_scenario.py", "relativeCreated": 17977.205514907837, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 63, "module": "test_rest_api_scenario", "process": 15359, "name": "test_rest_api_scenario", "funcName": "test_rest_api_mul_val_intk_xo", "stack_info": null, "created": 1535494537.069574, "levelname": "INFO", "msg": "Creating intkey batches", "args": null, "levelno": 20, "msecs": 69.57411766052246, "exc_info": null, "filename": "test_rest_api_scenario.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/scenario/test_rest_api_scenario.py", "relativeCreated": 17979.49481010437, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 79, "module": "test_rest_api_scenario", "process": 15359, "name": "test_rest_api_scenario", "funcName": "test_rest_api_mul_val_intk_xo", "stack_info": null, "created": 1535494537.0718634, "levelname": "INFO", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelno": 20, "msecs": 71.86341285705566, "exc_info": null, "filename": "test_rest_api_scenario.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/scenario/test_rest_api_scenario.py", "relativeCreated": 17980.034112930298, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 83, "module": "test_rest_api_scenario", "process": 15359, "name": "test_rest_api_scenario", "funcName": "test_rest_api_mul_val_intk_xo", "stack_info": null, "created": 1535494537.0724027, "levelname": "INFO", "msg": "Creating keys for xo users", "args": null, "levelno": 20, "msecs": 72.4027156829834, "exc_info": null, "filename": "test_rest_api_scenario.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/utils.py", "relativeCreated": 17980.20887374878, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 266, "module": "utils", "process": 15359, "name": "utils", "funcName": "_send_cmd", "stack_info": null, "created": 1535494537.0725775, "levelname": "INFO", "msg": "Sending sawtooth keygen aditya --force", "args": null, "levelno": 20, "msecs": 72.57747650146484, "exc_info": null, "filename": "utils.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/utils.py", "relativeCreated": 18384.567737579346, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 266, "module": "utils", "process": 15359, "name": "utils", "funcName": "_send_cmd", "stack_info": null, "created": 1535494537.4769363, "levelname": "INFO", "msg": "Sending sawtooth keygen singh --force", "args": null, "levelno": 20, "msecs": 476.93634033203125, "exc_info": null, "filename": "utils.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/scenario/test_rest_api_scenario.py", "relativeCreated": 18784.59644317627, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 89, "module": "test_rest_api_scenario", "process": 15359, "name": "test_rest_api_scenario", "funcName": "test_rest_api_mul_val_intk_xo", "stack_info": null, "created": 1535494537.876965, "levelname": "INFO", "msg": "Submitting xo batches to the handlers", "args": null, "levelno": 20, "msecs": 876.9650459289551, "exc_info": null, "filename": "test_rest_api_scenario.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}, {"pathname": "/home/aditya/sawtooth-local/rest_api/tests/api_test/utils.py", "relativeCreated": 18789.876461029053, "exc_text": null, "threadName": "MainThread", "processName": "MainProcess", "lineno": 266, "module": "utils", "process": 15359, "name": "utils", "funcName": "_send_cmd", "stack_info": null, "created": 1535494537.882245, "levelname": "INFO", "msg": "Sending xo create game-1 --username aditya --url http://10.223.155.43:8008 --wait 300", "args": null, "levelno": 20, "msecs": 882.2450637817383, "exc_info": null, "filename": "utils.py", "asctime": "2018-08-28 15:15:37", "thread": 140335417706240}], "traceback": [{"path": "scenario/test_rest_api_scenario.py", "lineno": 104, "message": ""}, {"path": "utils.py", "lineno": 270, "message": "in _send_cmd"}, {"path": "/usr/lib/python3.5/subprocess.py", "lineno": 708, "message": "CalledProcessError"}], "outcome": "failed"}, "lineno": 51, "teardown": {"duration": 0.014801979064941406, "log": [], "outcome": "passed"}, "domain": "TestScenario.test_rest_api_mul_val_intk_xo", "setup": {"duration": 0.0003733634948730469, "log": [], "outcome": "passed"}, "keywords": ["api_test", "TestScenario", "test_rest_api_mul_val_intk_xo", "scenario", "()", "scenario/test_rest_api_scenario.py"], "outcome": "failed"}], "collectors": [{"nodeid": "", "children": [{"type": "Module", "nodeid": "get/test_rest_api_get_batch.py"}, {"type": "Module", "nodeid": "get/test_rest_api_get_block.py"}, {"type": "Module", "nodeid": "get/test_rest_api_get_peers.py"}, {"type": "Module", "nodeid": "get/test_rest_api_get_receipts.py"}, {"type": "Module", "nodeid": "get/test_rest_api_get_state.py"}, {"type": "Module", "nodeid": "get/test_rest_api_get_transaction.py"}, {"type": "Module", "nodeid": "mul/test_rest_api_mul_validator.py"}, {"type": "Module", "nodeid": "post/test_rest_api_post.py"}, {"type": "Module", "nodeid": "scenario/test_rest_api_scenario.py"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()", "children": [{"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list", "lineno": 57, "domain": "TestBatchList.test_api_get_batch_list"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_head", "lineno": 92, "domain": "TestBatchList.test_api_get_batch_list_head"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_bad_head", "lineno": 124, "domain": "TestBatchList.test_api_get_batch_list_bad_head"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_id", "lineno": 139, "domain": "TestBatchList.test_api_get_batch_list_id"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_bad_id", "lineno": 174, "domain": "TestBatchList.test_api_get_batch_list_bad_id"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_head_and_id", "lineno": 188, "domain": "TestBatchList.test_api_get_batch_list_head_and_id"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_paginated_batch_list", "lineno": 223, "domain": "TestBatchList.test_api_get_paginated_batch_list"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_limit", "lineno": 242, "domain": "TestBatchList.test_api_get_batch_list_limit"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_invalid_start", "lineno": 279, "domain": "TestBatchList.test_api_get_batch_list_invalid_start"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_invalid_limit", "lineno": 298, "domain": "TestBatchList.test_api_get_batch_list_invalid_limit"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_list_reversed", "lineno": 316, "domain": "TestBatchList.test_api_get_batch_list_reversed"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_key_params", "lineno": 352, "domain": "TestBatchList.test_api_get_batch_key_params"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_api_get_batch_param_link_val", "lineno": 361, "domain": "TestBatchList.test_api_get_batch_param_link_val"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()::test_rest_api_check_batches_count", "lineno": 376, "domain": "TestBatchList.test_rest_api_check_batches_count"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::()", "children": [{"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::()::test_api_get_batch_id", "lineno": 388, "domain": "TestBatchGet.test_api_get_batch_id"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::()::test_api_get_bad_batch_id", "lineno": 413, "domain": "TestBatchGet.test_api_get_bad_batch_id"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()", "children": [{"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_post_batch_status_15ids", "lineno": 429, "domain": "TestBatchStatusesList.test_api_post_batch_status_15ids"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_post_batch_status_10ids", "lineno": 446, "domain": "TestBatchStatusesList.test_api_post_batch_status_10ids"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses", "lineno": 466, "domain": "TestBatchStatusesList.test_api_get_batch_statuses"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_many_ids", "lineno": 486, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_many_ids"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_bad_id", "lineno": 507, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_bad_id"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_invalid_query", "lineno": 522, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_invalid_query"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_wait", "lineno": 537, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_wait"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_invalid", "lineno": 557, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_invalid"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_unknown", "lineno": 575, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_unknown"}, {"path": "get/test_rest_api_get_batch.py", "type": "Function", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()::test_api_get_batch_statuses_default_wait", "lineno": 593, "domain": "TestBatchStatusesList.test_api_get_batch_statuses_default_wait"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_batch.py", "children": [{"type": "Class", "nodeid": "get/test_rest_api_get_batch.py::TestBatchList"}, {"type": "Class", "nodeid": "get/test_rest_api_get_batch.py::TestBatchGet"}, {"type": "Class", "nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::()", "children": [{"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list", "lineno": 53, "domain": "TestBlockList.test_api_get_block_list"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_head", "lineno": 68, "domain": "TestBlockList.test_api_get_block_list_head"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_bad_head", "lineno": 84, "domain": "TestBlockList.test_api_get_block_list_bad_head"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_id", "lineno": 97, "domain": "TestBlockList.test_api_get_block_list_id"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_bad_id", "lineno": 116, "domain": "TestBlockList.test_api_get_block_list_bad_id"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_head_and_id", "lineno": 130, "domain": "TestBlockList.test_api_get_block_list_head_and_id"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_paginated_block_list", "lineno": 147, "domain": "TestBlockList.test_api_get_paginated_block_list"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_start_id", "lineno": 166, "domain": "TestBlockList.test_api_get_block_list_start_id"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_invalid_start", "lineno": 185, "domain": "TestBlockList.test_api_get_block_list_invalid_start"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_limit", "lineno": 203, "domain": "TestBlockList.test_api_get_block_list_limit"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_invalid_limit", "lineno": 221, "domain": "TestBlockList.test_api_get_block_list_invalid_limit"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_list_reversed", "lineno": 240, "domain": "TestBlockList.test_api_get_block_list_reversed"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_link_val", "lineno": 259, "domain": "TestBlockList.test_api_get_block_link_val"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_block_key_params", "lineno": 274, "domain": "TestBlockList.test_api_get_block_key_params"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_each_batch_id_length", "lineno": 283, "domain": "TestBlockList.test_api_get_each_batch_id_length"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_api_get_first_block_id_length", "lineno": 295, "domain": "TestBlockList.test_api_get_first_block_id_length"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_post_max_batches", "lineno": 308, "domain": "TestBlockList.test_rest_api_check_post_max_batches"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_head_signature", "lineno": 317, "domain": "TestBlockList.test_rest_api_check_head_signature"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_family_version", "lineno": 327, "domain": "TestBlockList.test_rest_api_check_family_version"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_input_output_content", "lineno": 336, "domain": "TestBlockList.test_rest_api_check_input_output_content"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_signer_public_key", "lineno": 345, "domain": "TestBlockList.test_rest_api_check_signer_public_key"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_check_blocks_count", "lineno": 353, "domain": "TestBlockList.test_rest_api_check_blocks_count"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()::test_rest_api_blk_content_head_signature", "lineno": 364, "domain": "TestBlockList.test_rest_api_blk_content_head_signature"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_block.py::TestBlockList::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet::()", "children": [{"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockGet::()::test_api_get_block_id", "lineno": 381, "domain": "TestBlockGet.test_api_get_block_id"}, {"path": "get/test_rest_api_get_block.py", "type": "Function", "nodeid": "get/test_rest_api_get_block.py::TestBlockGet::()::test_api_get_bad_block_id", "lineno": 396, "domain": "TestBlockGet.test_api_get_bad_block_id"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_block.py::TestBlockGet::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_block.py", "children": [{"type": "Class", "nodeid": "get/test_rest_api_get_block.py::TestBlockList"}, {"type": "Class", "nodeid": "get/test_rest_api_get_block.py::TestBlockGet"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_peers.py::TestPeerList::()", "children": [{"path": "get/test_rest_api_get_peers.py", "type": "Function", "nodeid": "get/test_rest_api_get_peers.py::TestPeerList::()::test_api_get_peer_list", "lineno": 35, "domain": "TestPeerList.test_api_get_peer_list"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_peers.py::TestPeerList", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_peers.py::TestPeerList::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_peers.py", "children": [{"type": "Class", "nodeid": "get/test_rest_api_get_peers.py::TestPeerList"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()", "children": [{"path": "get/test_rest_api_get_receipts.py", "type": "Function", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_get_reciept_invalid_id", "lineno": 42, "domain": "TestReceiptsList.test_api_get_reciept_invalid_id"}, {"path": "get/test_rest_api_get_receipts.py", "type": "Function", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_get_reciepts_multiple_transactions", "lineno": 56, "domain": "TestReceiptsList.test_api_get_reciepts_multiple_transactions"}, {"path": "get/test_rest_api_get_receipts.py", "type": "Function", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_get_reciepts_single_transactions", "lineno": 74, "domain": "TestReceiptsList.test_api_get_reciepts_single_transactions"}, {"path": "get/test_rest_api_get_receipts.py", "type": "Function", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_post_reciepts_single_transactions", "lineno": 90, "domain": "TestReceiptsList.test_api_post_reciepts_single_transactions"}, {"path": "get/test_rest_api_get_receipts.py", "type": "Function", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_post_reciepts_invalid_transactions", "lineno": 106, "domain": "TestReceiptsList.test_api_post_reciepts_invalid_transactions"}, {"path": "get/test_rest_api_get_receipts.py", "type": "Function", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()::test_api_post_reciepts_multiple_transactions", "lineno": 121, "domain": "TestReceiptsList.test_api_post_reciepts_multiple_transactions"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_receipts.py", "children": [{"type": "Class", "nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::()", "children": [{"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list", "lineno": 54, "domain": "TestStateList.test_api_get_state_list"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_invalid_batch", "lineno": 71, "domain": "TestStateList.test_api_get_state_list_invalid_batch"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_head", "lineno": 83, "domain": "TestStateList.test_api_get_state_list_head"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_bad_head", "lineno": 99, "domain": "TestStateList.test_api_get_state_list_bad_head"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_address", "lineno": 116, "domain": "TestStateList.test_api_get_state_list_address"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_bad_address", "lineno": 133, "domain": "TestStateList.test_api_get_state_list_bad_address"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_paginated_state_list", "lineno": 149, "domain": "TestStateList.test_api_get_paginated_state_list"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_paginated_state_list_limit", "lineno": 168, "domain": "TestStateList.test_api_get_paginated_state_list_limit"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_paginated_state_list_start", "lineno": 185, "domain": "TestStateList.test_api_get_paginated_state_list_start"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_bad_paging", "lineno": 202, "domain": "TestStateList.test_api_get_state_list_bad_paging"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_invalid_start", "lineno": 222, "domain": "TestStateList.test_api_get_state_list_invalid_start"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_invalid_limit", "lineno": 241, "domain": "TestStateList.test_api_get_state_list_invalid_limit"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_list_reversed", "lineno": 259, "domain": "TestStateList.test_api_get_state_list_reversed"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_prefix_namespace", "lineno": 277, "domain": "TestStateList.test_api_get_state_data_address_prefix_namespace"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_head_wildcard_character", "lineno": 289, "domain": "TestStateList.test_api_get_state_data_head_wildcard_character"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_head_partial_character", "lineno": 311, "domain": "TestStateList.test_api_get_state_data_head_partial_character"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_partial_character", "lineno": 327, "domain": "TestStateList.test_api_get_state_data_address_partial_character"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_length", "lineno": 344, "domain": "TestStateList.test_api_get_state_data_address_length"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_with_odd_hex_value", "lineno": 358, "domain": "TestStateList.test_api_get_state_data_address_with_odd_hex_value"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_with_reduced_length", "lineno": 372, "domain": "TestStateList.test_api_get_state_data_address_with_reduced_length"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_64_Hex", "lineno": 386, "domain": "TestStateList.test_api_get_state_data_address_64_Hex"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_data_address_alter_bytes", "lineno": 401, "domain": "TestStateList.test_api_get_state_data_address_alter_bytes"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_link_val", "lineno": 418, "domain": "TestStateList.test_api_get_state_link_val"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_state_key_params", "lineno": 433, "domain": "TestStateList.test_api_get_state_key_params"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_api_get_each_state_head_length", "lineno": 442, "domain": "TestStateList.test_api_get_each_state_head_length"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()::test_rest_api_check_state_count", "lineno": 453, "domain": "TestStateList.test_rest_api_check_state_count"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_state.py::TestStateList::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet::()", "children": [{"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateGet::()::test_api_get_state_address", "lineno": 466, "domain": "TestStateGet.test_api_get_state_address"}, {"path": "get/test_rest_api_get_state.py", "type": "Function", "nodeid": "get/test_rest_api_get_state.py::TestStateGet::()::test_api_get_bad_address", "lineno": 477, "domain": "TestStateGet.test_api_get_bad_address"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_state.py::TestStateGet::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_state.py", "children": [{"type": "Class", "nodeid": "get/test_rest_api_get_state.py::TestStateList"}, {"type": "Class", "nodeid": "get/test_rest_api_get_state.py::TestStateGet"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()", "children": [{"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list", "lineno": 49, "domain": "TestTransactionList.test_api_get_transaction_list"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_head", "lineno": 79, "domain": "TestTransactionList.test_api_get_transaction_list_head"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_bad_head", "lineno": 108, "domain": "TestTransactionList.test_api_get_transaction_list_bad_head"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_id", "lineno": 123, "domain": "TestTransactionList.test_api_get_transaction_list_id"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_bad_id", "lineno": 153, "domain": "TestTransactionList.test_api_get_transaction_list_bad_id"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_head_and_id", "lineno": 167, "domain": "TestTransactionList.test_api_get_transaction_list_head_and_id"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_paginated_transaction_list", "lineno": 198, "domain": "TestTransactionList.test_api_get_paginated_transaction_list"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_bad_paging", "lineno": 217, "domain": "TestTransactionList.test_api_get_transaction_bad_paging"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_invalid_start", "lineno": 236, "domain": "TestTransactionList.test_api_get_transaction_list_invalid_start"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_invalid_limit", "lineno": 254, "domain": "TestTransactionList.test_api_get_transaction_list_invalid_limit"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_list_reversed", "lineno": 273, "domain": "TestTransactionList.test_api_get_transaction_list_reversed"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transactions_link_val", "lineno": 291, "domain": "TestTransactionList.test_api_get_transactions_link_val"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transactions_key_params", "lineno": 306, "domain": "TestTransactionList.test_api_get_transactions_key_params"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_api_get_transaction_id_length", "lineno": 315, "domain": "TestTransactionList.test_api_get_transaction_id_length"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()::test_rest_api_check_transactions_count", "lineno": 327, "domain": "TestTransactionList.test_rest_api_check_transactions_count"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet::()", "children": [{"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet::()::test_api_get_transaction_id", "lineno": 339, "domain": "TesttransactionGet.test_api_get_transaction_id"}, {"path": "get/test_rest_api_get_transaction.py", "type": "Function", "nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet::()::test_api_get_transaction_bad_id", "lineno": 361, "domain": "TesttransactionGet.test_api_get_transaction_bad_id"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet", "children": [{"type": "Instance", "nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet::()"}], "outcome": "passed"}, {"nodeid": "get/test_rest_api_get_transaction.py", "children": [{"type": "Class", "nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList"}, {"type": "Class", "nodeid": "get/test_rest_api_get_transaction.py::TesttransactionGet"}], "outcome": "passed"}, {"nodeid": "mul/test_rest_api_mul_validator.py::TestMultiValidator::()", "children": [{"path": "mul/test_rest_api_mul_validator.py", "type": "Function", "nodeid": "mul/test_rest_api_mul_validator.py::TestMultiValidator::()::test_rest_api_mul_val_Node", "lineno": 97, "domain": "TestMultiValidator.test_rest_api_mul_val_Node"}], "outcome": "passed"}, {"nodeid": "mul/test_rest_api_mul_validator.py::TestMultiValidator", "children": [{"type": "Instance", "nodeid": "mul/test_rest_api_mul_validator.py::TestMultiValidator::()"}], "outcome": "passed"}, {"nodeid": "mul/test_rest_api_mul_validator.py", "children": [{"type": "Class", "nodeid": "mul/test_rest_api_mul_validator.py::TestMultiValidator"}], "outcome": "passed"}, {"nodeid": "post/test_rest_api_post.py::TestPost::()", "children": [{"path": "post/test_rest_api_post.py", "type": "Function", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_post_batch", "lineno": 68, "domain": "TestPost.test_rest_api_post_batch"}, {"path": "post/test_rest_api_post.py", "type": "Function", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_no_batches", "lineno": 148, "domain": "TestPost.test_rest_api_no_batches"}, {"path": "post/test_rest_api_post.py", "type": "Function", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_bad_protobuf", "lineno": 160, "domain": "TestPost.test_rest_api_bad_protobuf"}, {"path": "post/test_rest_api_post.py", "type": "Function", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_post_wrong_header", "lineno": 172, "domain": "TestPost.test_rest_api_post_wrong_header"}, {"path": "post/test_rest_api_post.py", "type": "Function", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_post_same_txns", "lineno": 225, "domain": "TestPost.test_rest_api_post_same_txns"}, {"path": "post/test_rest_api_post.py", "type": "Function", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_rest_api_multiple_txns_batches", "lineno": 279, "domain": "TestPost.test_rest_api_multiple_txns_batches"}, {"path": "post/test_rest_api_post.py", "type": "Function", "nodeid": "post/test_rest_api_post.py::TestPost::()::test_api_post_batch_different_signer", "lineno": 355, "domain": "TestPost.test_api_post_batch_different_signer"}], "outcome": "passed"}, {"nodeid": "post/test_rest_api_post.py::TestPost", "children": [{"type": "Instance", "nodeid": "post/test_rest_api_post.py::TestPost::()"}], "outcome": "passed"}, {"nodeid": "post/test_rest_api_post.py", "children": [{"type": "Class", "nodeid": "post/test_rest_api_post.py::TestPost"}], "outcome": "passed"}, {"nodeid": "scenario/test_rest_api_scenario.py::TestScenario::()", "children": [{"path": "scenario/test_rest_api_scenario.py", "type": "Function", "nodeid": "scenario/test_rest_api_scenario.py::TestScenario::()::test_rest_api_mul_val_intk_xo", "lineno": 51, "domain": "TestScenario.test_rest_api_mul_val_intk_xo"}], "outcome": "passed"}, {"nodeid": "scenario/test_rest_api_scenario.py::TestScenario", "children": [{"type": "Instance", "nodeid": "scenario/test_rest_api_scenario.py::TestScenario::()"}], "outcome": "passed"}, {"nodeid": "scenario/test_rest_api_scenario.py", "children": [{"type": "Class", "nodeid": "scenario/test_rest_api_scenario.py::TestScenario"}], "outcome": "passed"}]}